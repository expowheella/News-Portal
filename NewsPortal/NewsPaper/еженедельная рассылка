 ## D6.5 Еженедельная рассылка
 
#### 1. Один раз в неделю по понедельникам отправляются письма подписчикам с появившимися новостями по категориям подписки.
Для этого создадим файл:
#### NewsPaper/management/commands/runapscheduler.py
    import logging
     
    from django.conf import settings
    
    from apscheduler.schedulers.blocking import BlockingScheduler
    from apscheduler.triggers.cron import CronTrigger
    from django.core.management.base import BaseCommand
    from django_apscheduler.jobstores import DjangoJobStore
    from django_apscheduler.models import DjangoJobExecution
    from django_apscheduler import util
    
    # загружаем функцию которую мы написали в signals.py
    from NewsPaper.signals import week_post_2
    # from NewsPortal.NewsPaper.models import Post
    
    logger = logging.getLogger(__name__)
    
    
    def my_job():
        # Your job processing logic here...
        print('Hello from jobscheduler!')
        
        # здесь вызываем написанную нами функцию в NewsPaper/signals.py
        week_post_2()
        pass
    
    
    # The `close_old_connections` decorator ensures that database connections, that have become
    # unusable or are obsolete, are closed before and after our job has run.
    @util.close_old_connections
    def delete_old_job_executions(max_age=604_800):
        """
        This job deletes APScheduler job execution entries older than `max_age` from the database.
        It helps to prevent the database from filling up with old historical records that are no
        longer useful.
    
        :param max_age: The maximum length of time to retain historical job execution records.
                        Defaults to 7 days.
        """
        DjangoJobExecution.objects.delete_old_job_executions(max_age)
    
    
    class Command(BaseCommand):
        help = "Runs APScheduler."
    
        def handle(self, *args, **options):
            scheduler = BlockingScheduler(timezone=settings.TIME_ZONE)
            scheduler.add_jobstore(DjangoJobStore(), "default")
    
            scheduler.add_job(
                my_job,
                trigger=CronTrigger(week="*/1"),  # Every 1 week
                id="my_job",  # The `id` assigned to each job MUST be unique
                max_instances=1,
                replace_existing=True,
            )
            logger.info("Added job 'my_job'.")
    
            scheduler.add_job(
                delete_old_job_executions,
                trigger=CronTrigger(
                    day_of_week="mon", hour="00", minute="00"
                ),  # Midnight on Monday, before start of the next work week.
                id="delete_old_job_executions",
                max_instances=1,
                replace_existing=True,
            )
            logger.info(
                "Added weekly job: 'delete_old_job_executions'."
            )
    
            try:
                logger.info("Starting scheduler...")
                scheduler.start()
            except KeyboardInterrupt:
                logger.info("Stopping scheduler...")
                scheduler.shutdown()
                logger.info("Scheduler shut down successfully!")

#### в settings.py добавим следующие параметры:

    INSTALLED_APPS = [
    ...
    # добавляем приложение для запуска периодических задач
    'django_apscheduler',
    ]

    ...

    # Указываем формат даты для scheduler
    APSCHEDULER_DATETIME_FORMAT = "N j, Y, f:s a"
    
    # Время на выполнение задачи (задача снимается, если не успеет выполниться)
    APSCHEDULER_RUN_NOW_TIMEOUT = 25  # seconds

 #### 2. в signals.py напишем функцию, которая отвечает за формирование и отправку писем:
    def week_post_2():
        if date.today().weekday() == 1:  # если сегодня понедельник
            start = date.today() - timedelta(7)  # вычтем от сегодняшнего дня 7 дней. Это будет началом диапазона выборки
            # дат
            finish = date.today()  # сегодняшний день - конец диапазона выборки дат
    
            # список постов, отфильтрованный по дате создания в диапазоне start и finish
            list_of_posts = Post.objects.filter(date_created__range=(start, finish))
    
            # все возможные категории
            categories = Category.objects.all()
    
            # возьмём все возможные категории и пробежимся по ним
            for category in categories:
                # создадим список, куда будем собирать почтовые адреса подписчиков
                subscribers_emails = []
                # из списка всех пользователей
                for user in User.objects.all():
                    # отфильтруем только тех, кто подписан на конкретную категорию, по которой идёт выборка
                    # делаем это за счёт того, что в модели Category в поле subscribers
                    # мы добавили имя обратной связи от User к Category, чтобы получить доступ
                    # ко всем связанным объектам пользователя --> related_name='subscriber'
                    user.subscriber.filter(article_category=category)
                    # добавляем в список адреса пользователей, подписанных на текущую категорию
                    subscribers_emails.append(user.email)
    
                    # укажем контекст в виде словаря, который будет рендерится в шаблоне week_posts.html
                    html_content = render_to_string('NewsPaper/week_posts.html',
                                                    {'posts': list_of_posts, 'category': category})
                    
                    # формируем тело письма
                    msg = EmailMultiAlternatives(
                        subject=f'Все новости за прошедшую неделю',
                        from_email=settings.DEFAULT_FROM_EMAIL,
                        to=subscribers_emails,
                    )
                    msg.attach_alternative(html_content, "text/html")  
                    msg.send()  # отсылаем

#### 3. в папке templates/NewsPaper создадим шаблон week_posts.html, который будет отвечать за формирование содержания html-письма:

    <!DOCTYPE html>
    {% load i18n %}
    
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
    <h1 style="color:#0000ff">{% trans "Дайджест новостей за прошедшую неделю в категории" %} {{ category }}!</h1>
    <table>
        {% for post in posts %}
        <tr>
            <td>
                <a href="http://localhost:8000/news/{{ post.id }}">{{ post.title }}</a>
            </td>
        </tr>
        {% endfor %}
    </table>
    </body>
    </html>